//$file${.::main.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qhsmtst.qm
// File:  ${.::main.cpp}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::main.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <Arduino.h>

#include "qpcpp.hpp"    // QP/C++ framework
#include "qhsmtst.hpp"  // QHsmTst state machine
#include "esp_sleep.h"

void setup() {
    Serial.begin(115200);
    APP::the_sm->init(0U);  // trigger the initial tran. in the test SM
    Serial.print("Waiting for input >>> ");
}

void loop() {
    char rc;

    if (Serial.available() > 0) {
        rc = Serial.read();
        Serial.print("Read character '");
        Serial.print(rc);
        Serial.println("'");

        QP::QSignal sig = 0U;
        if ('a' <= rc && rc <= 'j') {  // in range?
            sig = (QP::QSignal)(rc - 'a' + APP::A_SIG);
        } else if ('A' <= rc && rc <= 'J') {  // in range?
            sig = (QP::QSignal)(rc - 'A' + APP::A_SIG);
        } else if ((rc == 'x') || (rc == 'X')) {  // x or X?
            sig = APP::TERMINATE_SIG;  // terminate the interactive test

        } else if ((rc == 's') || (rc == 'S')) {  // deep sleep
            Serial.println("Sleeping");
            esp_deep_sleep_start();
            sig = APP::IGNORE_SIG;  // terminate the interactive test
        } else {
            sig = APP::IGNORE_SIG;
        }

        QP::QEvt const e(sig);
        APP::the_sm->dispatch(&e, 0U);  // dispatch the event
    }
}

//............................................................................
extern "C" Q_NORETURN Q_onError(char const *const file, int_t const line) {
    // FPRINTF_S(stderr, "Assertion failed in %s, line %d", file, line);
    Serial.println("Assertion failed");
    while (1) {
    }
}

namespace APP {
//............................................................................
void BSP_display(char const *msg) { Serial.println(msg); }
//............................................................................
void BSP_terminate(int16_t const result) {
    Serial.println("Bye Bye");
    while (1) {
    }
}

}  // namespace APP


